{
    "CP Main Template": {
        "prefix": "cp",
        "body": [
            "#include <bits/stdc++.h>",
            "",
            "using namespace std;",
            "",
            "template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }",
            "template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = \", \"; return os << '}'; }",
            "void dbg_out() { cerr << endl; }",
            "template<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }",
            "#ifdef LOCAL",
            "#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)",
            "#else",
            "#define dbg(...)",
            "#endif",
            "",
            "#define ar array",
            "#define ll long long",
            "#define ld long double",
            "#define sza(x) ((int)x.size())",
            "#define all(a) (a).begin(), (a).end()",
            "",
            "const int MAX_N = 1e5 + 5;",
            "const ll MOD = 1e9 + 7;",
            "const ll INF = 1e9;",
            "const ld EPS = 1e-9;",
            "",
            "",
            "",
            "void solve() {",
            "    ",
            "}",
            "",
            "int main() {",
            "    ios_base::sync_with_stdio(0);",
            "    cin.tie(0); cout.tie(0);",
            "    int tc = 1;",
            "    // cin >> tc;",
            "    for (int t = 1; t <= tc; t++) {",
            "        // cout << \"Case #\" << t << \": \";",
            "        solve();",
            "    }",
            "}"
        ],
        "description": "CP Main Template"
    },
    "Debugger Template": {
        "prefix": "debug",
        "body": [
            "template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }",
            "template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = \", \"; return os << '}'; }",
            "void dbg_out() { cerr << endl; }",
            "template<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }",
            "#ifdef LOCAL",
            "#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)",
            "#else",
            "#define dbg(...)",
            "#endif"
        ],
        "description": "Debugger Template"
    },
    "Randomiser": {
        "prefix": "rand",
        "body": [
            "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
            "ll rand(ll l, ll r) {return uniform_int_distribution(l, r)(rng);}"
        ],
        "description": "Randomiser"
    },
    "Atcoder Library": {
        "prefix": "atcoder",
        "body": [
            "#include <atcoder/all>",
            "using namespace atcoder;"
        ],
        "description": "Atcoder Library"
    },
    "Fast OI": {
        "prefix": "fastoi",
        "body": [
            "inline int readInt() {",
            "    int x = 0;",
            "    char ch = getchar_unlocked();",
            "    while (ch < '0' || ch > '9') ch = getchar_unlocked();",
            "    while ('0' <= ch && ch <= '9') {",
            "        x = (x << 3) + (x << 1) + ch - '0';",
            "        ch = getchar_unlocked();",
            "    }",
            "    return x;",
            "}"
        ],
        "description": "Fast OI"
    },
    "File input/output": {
        "prefix": "open_file",
        "body": [
            "void open_file(string filename) {",
            "    freopen((filename + \".in\").c_str(), \"r\", stdin);",
            "    freopen((filename + \".out\").c_str(), \"w\", stdout);",
            "}"
        ],
        "description": "File input/output"
    },
    "lambda function": {
        "prefix": "lambda",
        "body": [
            "auto ok = [&](int x) -> bool {",
            "",
            "};"
        ],
        "description": "lambda function"
    },
    "Complex": {
        "prefix": "complex",
        "body": [
            "#define P complex<double>",
            "#define X real()",
            "#define Y imag()",
            "inline istream& operator>>(istream &in, P &p) {double x, y; in >> x >> y, p = P(x, y); return in;}"
        ],
        "description": "Complex"
    },
    "int128": {
        "prefix": "int128",
        "body": [
            "__int128 read() {",
            "    __int128 x = 0, f = 1;",
            "    char ch = getchar();",
            "    while (ch < '0' || ch > '9') {",
            "        if (ch == '-') f = -1;",
            "        ch = getchar();",
            "    }",
            "    while (ch >= '0' && ch <= '9') {",
            "        x = x * 10 + ch - '0';",
            "        ch = getchar();",
            "    }",
            "    return x * f;",
            "}",
            "",
            "void print(__int128 x) {",
            "    if (x == 0) {",
            "        cout << 0;",
            "        return;",
            "    }    ",
            "    vector<int> tmp;",
            "    while (x) {",
            "        tmp.push_back(x % 10);",
            "        x /= 10;",
            "    }",
            "    for (int x : tmp) cout << x;",
            "}"
        ],
        "description": "int128"
    },
    "Disjoint Set Union": {
        "prefix": "dsu",
        "body": [
            "struct dsu {",
            "    vector<int> p, sz;",
            "    dsu(int n) {",
            "        p.resize(n); iota(p.begin(), p.end(), 0);",
            "        sz.assign(n, 1);",
            "    }",
            "    int find(int u) {return u == p[u] ? u : p[u] = find(p[u]);}",
            "    bool same(int u, int v) {return find(u) == find(v);}",
            "    bool merge(int u, int v) {",
            "        u = find(u), v = find(v);",
            "        if (u == v) return false;",
            "        if (sz[u] > sz[v]) swap(u, v);",
            "        sz[v] += sz[u];",
            "        p[u] = v;",
            "        return true;",
            "    }",
            "};"
        ],
        "description": "Disjoint Set Union"
    },
    "dsu (with rollback)": {
        "prefix": "dsu_persistent",
        "body": [
            "struct dsu { ",
            "    int num;",
            "    vector<int> p, sz;",
            "    stack<int> st;",
            "    void init(int n) {",
            "        num = n;",
            "        p.resize(n); iota(p.begin(), p.end(), 0);",
            "        sz.assign(n, 1);",
            "    }",
            "    int find(int u) {return u == p[u] ? u : find(p[u]);}",
            "    bool same(int u, int v) {return find(u) == find(v);}",
            "    bool merge(int u, int v) {",
            "        u = find(u), v = find(v);",
            "        if (u == v) return false;",
            "        if (sz[u] > sz[v]) swap(u, v);",
            "        num--;",
            "        sz[v] += sz[u];",
            "        p[u] = v;",
            "        st.push(u);",
            "        return true;",
            "    }",
            "    void rollback(int t) {",
            "        while (st.size() > t) {",
            "            int u = st.top(); st.pop();",
            "            num++;",
            "            sz[p[u]] -= sz[u];",
            "            p[u] = u;",
            "        }",
            "    }",
            "};"
        ],
        "description": "Persistent dsu (with rollback)"
    },
    "Persistent Queue": {
        "prefix": "queue_persistent",
        "body": [
            "struct persistent_queue {",
            "    const int MAX_L = 20;",
            "    int ver;",
            "    vector<int> back_id, sz, data;",
            "    vector<vector<int>> par;",
            "    persistent_queue(): ver(), data(1), par(1, vector<int>(MAX_L)), back_id(1), sz(1) {}",
            "    void push(int t, int x) {",
            "        ver++;",
            "        int u = data.size();",
            "        data.push_back(x);",
            "        par.push_back(vector<int>(MAX_L, back_id[t]));",
            "        back_id.push_back(u);",
            "        sz.push_back(sz[t] + 1);",
            "        for (int i = 1; i < MAX_L; i++) par[u][i] = par[par[u][i - 1]][i - 1];",
            "    }",
            "    int pop(int t) {",
            "        ver++;",
            "        int u = back_id[t], len = sz[t] - 1;",
            "        back_id.push_back(u);",
            "        sz.push_back(len);",
            "        for (int i = 0; i < MAX_L; i++) ",
            "            if (len & (1 << i)) ",
            "                u = par[u][i];",
            "        return data[u];",
            "    }",
            "};"
        ],
        "description": "Persistent Queue"
    },
    "Trie": {
        "prefix": "trie",
        "body": [
            "const int MAX_S = 2e3 + 5;",
            "const int MAX_C = 30;",
            "",
            "template<int NS, int NC> struct Trie {",
            "    int tr[NS][NC] = {}, cnt[NS] = {}, num = 0;",
            "    void insert(string s) {",
            "        int u = 0;",
            "        for (char c : s) {",
            "            if (!tr[u][c - 'A']) tr[u][c - 'A'] = ++num;",
            "            u = tr[u][c - 'A'];",
            "        }",
            "        cnt[u]++;",
            "    }",
            "    bool search(string s) { ",
            "        int u = 0;",
            "        for (char c : s) {",
            "            if (!tr[u][c - 'A']) return false;",
            "            u = tr[u][c - 'A'];",
            "        }",
            "        return cnt[u] > 0;",
            "    }",
            "};"
        ],
        "description": "Trie"
    },
    "Sparse Table": {
        "prefix": "sparse_table",
        "body": [
            "struct sparse_table {",
            "    vector<vector<int>> dp;",
            "    sparse_table(vector<int> &arr) {",
            "        int n = arr.size(), k = __lg(n) + 1;",
            "        dp.resize(k);",
            "        dp[0] = arr;",
            "        for (int j = 1; j < k; j++)",
            "            for (int i = 0; i + (1 << j) <= n; i++)",
            "                dp[j].push_back(min(dp[j - 1][i], dp[j - 1][i + (1 << (j - 1))]));",
            "    }",
            "    int query(int l, int r) {",
            "        int k = __lg(r - l + 1);",
            "        return min(dp[k][l], dp[k][r - (1 << k) + 1]);",
            "    }",
            "};"
        ],
        "description": "Sparse Table"
    },
    "Segment Tree (range sum, range set)": {
        "prefix": "segtree",
        "body": [
            "struct segtree { ",
            "    struct tdata {",
            "        ll sum, setval;",
            "        tdata(): sum(), setval(INF) {}",
            "        tdata(ll val): sum(val), setval(INF) {}",
            "        tdata(tdata l, tdata r): sum(l.sum + r.sum), setval(INF) {}",
            "    };",
            "    int ln(int node) {return 2 * node;}",
            "    int rn(int node) {return 2 * node + 1;}",
            "    int n; vector<tdata> st;",
            "    segtree(int _n): n(_n), st(4 * _n) {}",
            "    segtree(vector<int> &arr) : segtree(arr.size()) { build(arr, 1, 0, n - 1); }",
            "    void apply(int node, int start, int end, ll val) {",
            "        if (val == INF) return;",
            "        st[node].sum = val * (end - start + 1);",
            "        st[node].setval = val;",
            "    }",
            "    void pull_up(int node) {",
            "        st[node].sum = st[ln(node)].sum + st[rn(node)].sum;",
            "    }",
            "    void push_down(int node, int start, int end) {",
            "        if (start == end) return;",
            "        int mid = (start + end) / 2;",
            "        apply(ln(node), start, mid, st[node].setval);",
            "        apply(rn(node), mid + 1, end, st[node].setval);",
            "        st[node].setval = INF;",
            "    }",
            "    void build(vector<int> &arr, int node, int start, int end) {",
            "        if (start == end) {",
            "            st[node] = tdata(arr[start]);",
            "            return;",
            "        }",
            "        int mid = (start + end) / 2;",
            "        build(arr, ln(node), start, mid);",
            "        build(arr, rn(node), mid + 1, end);",
            "        pull_up(node);",
            "    }",
            "    void update(int node, int start, int end, int idx, ll val) {",
            "        if (start == end) {",
            "            apply(node, start, end, val);",
            "            return;",
            "        }",
            "        push_down(node, start, end);",
            "        int mid = (start + end) / 2;",
            "        if (idx <= mid) update(ln(node), start, mid, idx, val);",
            "        else update(rn(node), mid + 1, end, idx, val);",
            "        pull_up(node);",
            "    }",
            "    void update(int node, int start, int end, int l, int r, ll val) {",
            "        if (r < start || end < l) return;",
            "        if (l <= start && end <= r) {",
            "            apply(node, start, end, val);",
            "            return;",
            "        }",
            "        push_down(node, start, end);",
            "        int mid = (start + end) / 2;",
            "        update(ln(node), start, mid, l, r, val);",
            "        update(rn(node), mid + 1, end, l, r, val);",
            "        pull_up(node);",
            "    }",
            "    tdata query(int node, int start, int end, int l, int r) {",
            "        if (r < start || end < l) return tdata();",
            "        if (l <= start && end <= r) return st[node];",
            "        push_down(node, start, end);",
            "        int mid = (start + end) / 2;",
            "        return tdata(query(ln(node), start, mid, l, r), query(rn(node), mid + 1, end, l, r));",
            "    }",
            "    void update(int idx, ll val) { update(1, 0, n - 1, idx, val); }",
            "    void update(int l, int r, ll val) { update(1, 0, n - 1, l, r, val); }",
            "    tdata query(int l, int r) { return query(1, 0, n - 1, l, r); }",
            "};"
        ],
        "description": "Segment Tree (range sum, range set)"
    },
    "Dynamic Segment Tree (range sum, range set)": {
        "prefix": "segtree_dynamic",
        "body": [
            "struct segtree { ",
            "    struct tdata {",
            "        tdata *ln = NULL, *rn = NULL;",
            "        ll start, end, sum, setval;",
            "        tdata(): start(), end(), sum(), setval(INF) {}",
            "        tdata(int start, int end, ll val): start(start), end(end), sum(val), setval(INF) {}",
            "        tdata(tdata l, tdata r): start(l.start), end(r.end), sum(l.sum + r.sum), setval(INF) {}",
            "        void init() {",
            "            if (ln == NULL || rn = NULL) {",
            "                int mid = (start + end) / 2;",
            "                ln = new tdata(start, mid, 0), rn = new tdata(mid + 1, end, 0);",
            "            }",
            "        }",
            "    };",
            "    int n; tdata *st;",
            "    segtree(int _n): n(_n) { st = new tdata(0, _n - 1, 0); }",
            "    void apply(tdata *node, ll val) {",
            "        if (val == INF) return;",
            "        node->sum = val * (node->end - node->start + 1);",
            "        node->setval = val;",
            "    }",
            "    void pull_up(tdata *node) {",
            "        node->sum = node->ln->sum + node->rn->sum;",
            "    }",
            "    void push_down(tdata *node) {",
            "        if (node->start == node->end) return;",
            "        node->init();",
            "        apply(node->ln, node->setval);",
            "        apply(node->rn, node->setval);",
            "        node->setval = INF;",
            "    }",
            "    void update(tdata *node, int idx, ll val) {",
            "        if (node->start == node->end) {",
            "            apply(node, val);",
            "            return;",
            "        }",
            "        push_down(node);",
            "        node->init();",
            "        int mid = (node->start + node->end) / 2;",
            "        if (idx <= mid) update(node->ln, idx, val);",
            "        else update(node->rn, idx, val);",
            "        pull_up(node);",
            "    }",
            "    void update(tdata *node, int l, int r, ll val) {",
            "        if (r < node->start || node->end < l) return;",
            "        if (l <= node->start && node->end <= r) {",
            "            apply(node, val);",
            "            return;",
            "        }",
            "        push_down(node);",
            "        node->init();",
            "        update(node->ln, l, r, val);",
            "        update(node->rn, l, r, val);",
            "        pull_up(node);",
            "    }",
            "    tdata query(tdata *node, int l, int r) {",
            "        if (r < node->start || node->end < l) return tdata();",
            "        if (l <= node->start && node->end <= r) return *node;",
            "        push_down(node);",
            "        node->init();",
            "        return tdata(query(node->ln, l, r), query(node->rn, l, r));",
            "    }",
            "    void update(int idx, ll val) { update(st, idx, val); }",
            "    void update(int l, int r, ll val) { update(st, l, r, val); }",
            "    tdata query(int l, int r) { return query(st, l, r); }",
            "};"
        ],
        "description": "Dynamic Segment Tree (range sum, range set)"
    },
    "Persistent Segment Tree (range sum, range set, copy)": {
        "prefix": "segtree_persistent",
        "body": [
            "struct segtree { ",
            "    struct tdata {",
            "        tdata *ln = NULL, *rn = NULL;",
            "        ll sum, setval;",
            "        tdata(): sum(), setval(INF) {}",
            "        tdata(ll val): sum(val), setval(INF) {}",
            "        tdata(tdata *ln, tdata *rn, ll val): ln(ln), rn(rn), sum(val), setval(INF) {}",
            "        tdata(tdata l, tdata r): sum(l.sum + r.sum), setval(INF) {}",
            "        void init() {",
            "            if (ln == NULL || rn == NULL) {",
            "                ln = new tdata(), rn = new tdata();",
            "            }",
            "        }",
            "    };",
            "    int n, ver; vector<tdata*> st;",
            "    segtree(int _n, int q): n(_n), ver(), st(q) { st[0] = new tdata(); }",
            "    segtree(vector<int> &arr, int q): segtree(arr.size(), q) { build(arr, st[0], 0, n - 1); }",
            "    void apply(tdata *node, int start, int end, ll val) {",
            "        node->sum = val * (end - start + 1);",
            "        node->setval = val;",
            "    }",
            "    void pull_up(tdata *node) {",
            "        node->sum = node->ln->sum + node->rn->sum;",
            "    }",
            "    void push_down(tdata *node, int start, int end) {",
            "        if (start == end || node->setval == INF) return;",
            "        node->init();",
            "        int mid = (start + end) / 2;",
            "        apply(node->ln, start, mid, node->setval);",
            "        apply(node->rn, mid + 1, end, node->setval);",
            "        node->setval = INF;",
            "    }",
            "    void build(vector<int> &arr, tdata *node, int start, int end) {",
            "        if (start == end) {",
            "            *node = tdata(arr[start]);",
            "            return;",
            "        }",
            "        node->init();",
            "        int mid = (start + end) / 2;",
            "        build(arr, node->ln, start, mid);",
            "        build(arr, node->rn, mid + 1, end);",
            "        pull_up(node);",
            "    }",
            "    void update(tdata *node, int start, int end, int idx, ll val) {",
            "        if (start == end) {",
            "            apply(node, start, end, val);",
            "            return;",
            "        }",
            "        push_down(node, start, end);",
            "        int mid = (start + end) / 2;",
            "        if (idx <= mid) {",
            "            node->ln = new tdata(node->ln->ln, node->ln->rn, node->ln->sum);",
            "            update(node->ln, start, mid, idx, val);",
            "        }",
            "        else {",
            "            node->rn = new tdata(node->rn->ln, node->rn->rn, node->rn->sum);",
            "            update(node->rn, mid + 1, end, idx, val);",
            "        }",
            "        pull_up(node);",
            "    }",
            "    void update(tdata *node, int start, int end, int l, int r, ll val) {",
            "        if (r < start || end < l) return;",
            "        if (l <= start && end <= r) {",
            "            apply(node, start, end, val);",
            "            return;",
            "        }",
            "        push_down(node, start, end);",
            "        int mid = (start + end) / 2;",
            "        node->ln = new tdata(node->ln->ln, node->ln->rn, node->ln->sum);",
            "        node->rn = new tdata(node->rn->ln, node->rn->rn, node->rn->sum);",
            "        update(node->ln, start, mid, l, r, val);",
            "        update(node->rn, mid + 1, end, l, r, val);",
            "        pull_up(node);",
            "    }",
            "    tdata query(tdata *node, int start, int end, int l, int r) {",
            "        if (r < start || end < l) return tdata();",
            "        if (l <= start && end <= r) return *node;",
            "        push_down(node, start, end);",
            "        int mid = (start + end) / 2;",
            "        return tdata(query(node->ln, start, mid, l, r), query(node->rn, mid + 1, end, l, r));",
            "    }",
            "    void update(int k, int idx, ll val) { update(st[k], 0, n - 1, idx, val); }",
            "    void update(int k, int l, int r, ll val) { update(st[k], 0, n - 1, l, r, val); }",
            "    tdata query(int k, int l, int r) { return query(st[k], 0, n - 1, l, r); }",
            "    void copy(int k) { st[++ver] = new tdata(st[k]->ln, st[k]->rn, st[k]->sum); }",
            "};"
        ],
        "description": "Persistent Segment Tree (range sum, range set, copy)"
    },
    "Segment Tree Beats": {
        "prefix": "segtreebeats",
        "body": [
            "struct segtree { ",
            "    struct tdata {",
            "        ll sum, addval, mx, mx2, mx_cnt, mn, mn2, mn_cnt;",
            "        tdata(): sum(), addval(), mx(-INF), mx2(-INF), mx_cnt(), mn(INF), mn2(INF), mn_cnt() {}",
            "        tdata(ll val): sum(val), addval(), mx(val), mx2(-INF), mx_cnt(1), mn(val), mn2(INF), mn_cnt(1) {}",
            "        tdata(tdata l, tdata r) {",
            "            sum = l.sum + r.sum;",
            "",
            "            mx = max(l.mx, r.mx);",
            "            mx2 = max(l.mx2, r.mx2);",
            "            mx_cnt = 0;",
            "            if (l.mx == mx) mx_cnt += l.mx_cnt;",
            "            else mx2 = max(mx2, l.mx);",
            "            if (r.mx == mx) mx_cnt += r.mx_cnt;",
            "            else mx2 = max(mx2, r.mx);",
            "",
            "            mn = min(l.mn, r.mn);",
            "            mn2 = min(l.mn2, r.mn2);",
            "            mn_cnt = 0;",
            "            if (l.mn == mn) mn_cnt += l.mn_cnt;",
            "            else mn2 = min(mn2, l.mn);",
            "            if (r.mn == mn) mn_cnt += r.mn_cnt;",
            "            else mn2 = min(mn2, r.mn);",
            "        }",
            "    };",
            "    int ln(int node) {return 2 * node;}",
            "    int rn(int node) {return 2 * node + 1;}",
            "    int n; vector<tdata> st;",
            "    segtree(int _n): n(_n), st(4 * _n) {}",
            "    segtree(vector<ll> &arr) : segtree(arr.size()) { build(arr, 1, 0, n - 1); }",
            "    void apply_add(int node, int start, int end, ll val) {",
            "        if (val == 0) return;",
            "        st[node].sum += val * (end - start + 1);",
            "        st[node].addval += val;",
            "",
            "        st[node].mx += val;",
            "        if (st[node].mx2 != -INF) st[node].mx2 += val; ",
            "",
            "        st[node].mn += val;",
            "        if (st[node].mn2 != INF) st[node].mn2 += val; ",
            "    }",
            "    void apply_min(int node, int start, int end, ll val) {",
            "        if (val >= st[node].mx) return;",
            "        st[node].sum -= (st[node].mx - val) * st[node].mx_cnt;",
            "        st[node].mx = val;",
            "",
            "        if (val < st[node].mn) st[node].mn = val;",
            "        else if (val < st[node].mn2) st[node].mn2 = val;",
            "    }",
            "    void apply_max(int node, int start, int end, ll val) {",
            "        if (val <= st[node].mn) return;",
            "        st[node].sum += (val - st[node].mn) * st[node].mn_cnt;",
            "        st[node].mn = val;",
            "",
            "        if (val > st[node].mx) st[node].mx = val;",
            "        else if (val > st[node].mx2) st[node].mx2 = val;",
            "    }",
            "    void pull_up(int node) {",
            "        st[node].sum = st[ln(node)].sum + st[rn(node)].sum;",
            "",
            "        st[node].mx = max(st[ln(node)].mx, st[rn(node)].mx);",
            "        st[node].mx2 = max(st[ln(node)].mx2, st[rn(node)].mx2);",
            "        st[node].mx_cnt = 0;",
            "        if (st[ln(node)].mx == st[node].mx) st[node].mx_cnt += st[ln(node)].mx_cnt;",
            "        else st[node].mx2 = max(st[node].mx2, st[ln(node)].mx);",
            "        if (st[rn(node)].mx == st[node].mx) st[node].mx_cnt += st[rn(node)].mx_cnt;",
            "        else st[node].mx2 = max(st[node].mx2, st[rn(node)].mx);",
            "",
            "        st[node].mn = min(st[ln(node)].mn, st[rn(node)].mn);",
            "        st[node].mn2 = min(st[ln(node)].mn2, st[rn(node)].mn2);",
            "        st[node].mn_cnt = 0;",
            "        if (st[ln(node)].mn == st[node].mn) st[node].mn_cnt += st[ln(node)].mn_cnt;",
            "        else st[node].mn2 = min(st[node].mn2, st[ln(node)].mn);",
            "        if (st[rn(node)].mn == st[node].mn) st[node].mn_cnt += st[rn(node)].mn_cnt;",
            "        else st[node].mn2 = min(st[node].mn2, st[rn(node)].mn);",
            "    }",
            "    void push_down(int node, int start, int end) {",
            "        if (start == end) return;",
            "        int mid = (start + end) / 2;",
            "        apply_add(ln(node), start, mid, st[node].addval);",
            "        apply_add(rn(node), mid + 1, end, st[node].addval);",
            "        st[node].addval = 0;",
            "        apply_min(ln(node), start, mid, st[node].mx);",
            "        apply_min(rn(node), mid + 1, end, st[node].mx);",
            "        apply_max(ln(node), start, mid, st[node].mn);",
            "        apply_max(rn(node), mid + 1, end, st[node].mn);",
            "    }",
            "    void build(vector<ll> &arr, int node, int start, int end) {",
            "        if (start == end) {",
            "            st[node] = tdata(arr[start]);",
            "            return;",
            "        }",
            "        int mid = (start + end) / 2;",
            "        build(arr, ln(node), start, mid);",
            "        build(arr, rn(node), mid + 1, end);",
            "        pull_up(node);",
            "    }",
            "    void update_add(int node, int start, int end, int l, int r, ll val) {",
            "        push_down(node, start, end);",
            "        if (r < start || end < l) return;",
            "        if (l <= start && end <= r) {",
            "            apply_add(node, start, end, val);",
            "            return;",
            "        }",
            "        int mid = (start + end) / 2;",
            "        update_add(ln(node), start, mid, l, r, val);",
            "        update_add(rn(node), mid + 1, end, l, r, val);",
            "        pull_up(node);",
            "    }",
            "    void update_min(int node, int start, int end, int l, int r, ll val) {",
            "        if (r < start || end < l || st[node].mx <= val) return;",
            "        if (l <= start && end <= r && st[node].mx2 < val) {",
            "            apply_min(node, start, end, val);",
            "            return;",
            "        }",
            "        push_down(node, start, end);",
            "        int mid = (start + end) / 2;",
            "        update_min(ln(node), start, mid, l, r, val);",
            "        update_min(rn(node), mid + 1, end, l, r, val);",
            "        pull_up(node);",
            "    }",
            "    void update_max(int node, int start, int end, int l, int r, ll val) {",
            "        if (r < start || end < l || st[node].mn >= val) return;",
            "        if (l <= start && end <= r && st[node].mn2 > val) {",
            "            apply_max(node, start, end, val);",
            "            return;",
            "        }",
            "        push_down(node, start, end);",
            "        int mid = (start + end) / 2;",
            "        update_max(ln(node), start, mid, l, r, val);",
            "        update_max(rn(node), mid + 1, end, l, r, val);",
            "        pull_up(node);",
            "    }",
            "    tdata query(int node, int start, int end, int l, int r) {",
            "        if (r < start || end < l) return tdata();",
            "        if (l <= start && end <= r) return st[node];",
            "        push_down(node, start, end);",
            "        int mid = (start + end) / 2;",
            "        return tdata(query(ln(node), start, mid, l, r), query(rn(node), mid + 1, end, l, r));",
            "    }",
            "    void update_add(int l, int r, ll val) { update_add(1, 0, n - 1, l, r, val); }",
            "    void update_min(int l, int r, ll val) { update_min(1, 0, n - 1, l, r, val); }",
            "    void update_max(int l, int r, ll val) { update_max(1, 0, n - 1, l, r, val); }",
            "    tdata query(int l, int r) { return query(1, 0, n - 1, l, r); }",
            "};"
        ],
        "description": "Segment Tree Beats"
    },
    "Fenwick Tree (PURQ && RUPQ && OST)": {
        "prefix": "fwtree",
        "body": [
            "struct fwtree {",
            "    const int MAX_L = 20;",
            "    int n; vector<ll> ft;",
            "    fwtree(int _n): n(_n), ft(_n + 1) {}",
            "    void update(int x, ll v) {",
            "        for (; x <= n; x += x&-x) ft[x] += v;",
            "    }",
            "    void update(int l, int r, ll v) {",
            "        update(l, v);",
            "        update(r + 1, -v);",
            "    }",
            "    ll sum(int x) {",
            "        ll res = 0;",
            "        for (; x; x -= x&-x) res += ft[x];",
            "        return res;",
            "    }",
            "    ll query(int l, int r) {return sum(r) - sum(l - 1);}",
            "    int find_by_order(int k) { // return 1 if k < 1 and returns N if k > N",
            "        int sum = 0, pos = 0;",
            "        for (int i = MAX_L; i >= 0; i--) {",
            "            if (pos + (1 << i) < n && sum + ft[pos + (1 << i)] < k) {",
            "                sum += ft[pos + (1 << i)];",
            "                pos += (1 << i);",
            "            }",
            "        }",
            "        return pos + 1; ",
            "    }",
            "    int order_of_key(int k) {return sum(k);}",
            "};"
        ],
        "description": "Fenwick Tree (PURQ && RUPQ && OST)"
    },
    "Fenwick Tree (RURQ)": {
        "prefix": "fwtree_RURQ",
        "body": [
            "struct fwtree {",
            "    int n; vector<ll> ft1, ft2;",
            "    fwtree(int _n): n(_n), ft1(_n + 1), ft2(_n + 1) {}",
            "    void update(vector<ll> &ft, int x, ll v) {",
            "        for (; x <= n; x += x&-x) ft[x] += v;",
            "    }",
            "    void update(int l, int r, ll v) {",
            "        update(ft1, l, v);",
            "        update(ft1, r + 1, -v);",
            "        update(ft2, l, v * (l - 1));",
            "        update(ft2, r + 1, -v * r);",
            "    }",
            "    ll sum(vector<ll> &ft, int x) {",
            "        ll res = 0;",
            "        for (; x; x -= x&-x) res += ft[x];",
            "        return res;",
            "    }",
            "    ll sum(int x) {return sum(ft1, x) * x - sum(ft2, x);}",
            "    ll query(int l, int r) {return sum(r) - sum(l - 1);}",
            "};"
        ],
        "description": "Fenwick Tree (RURQ)"
    },
    "Fenwick Tree (2D)": {
        "prefix": "fwtree2d",
        "body": [
            "struct fwtree {",
            "    int n; vector<vector<ll>> ft;",
            "    fwtree(int _n): n(_n), ft(_n + 1, vector<ll>(_n + 1)) {}",
            "    void update(int x, int y, ll v) {",
            "        for (int tx = x; tx <= n; tx += tx&-tx)",
            "            for (int ty = y; ty <= n; ty += ty&-ty)",
            "                ft[tx][ty] += v;",
            "    }",
            "    ll sum(int x, int y) {",
            "        ll res = 0;",
            "        for (int tx = x; tx; tx -= tx&-tx) ",
            "            for (int ty = y; ty; ty -= ty&-ty)",
            "                res += ft[tx][ty];",
            "        return res;",
            "    }",
            "    ll query(int x1, int y1, int x2, int y2) {return sum(x2, y2) - sum(x1 - 1, y2) - sum(x2, y1 - 1) + sum(x1 - 1, y1 - 1);}",
            "};"
        ],
        "description": "Fenwick Tree (2D)"
    },
    "Policy-based data structure": {
        "prefix": "pbds",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "using namespace __gnu_pbds;",
            "template <class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
            "template <class K, class V> using ordered_map = tree<K, V, less<K>, rb_tree_tag, tree_order_statistics_node_update>;"
        ],
        "description": "Policy-based data structure"
    },
    "nCk (no MOD)": {
        "prefix": "nCk_ll",
        "body": [
            "ll nCk(int n, int k) {",
            "    if (k < 0 || k > n) return 0;",
            "    k = min(k, n - k);",
            "    ll res = 1, tmp = 1;",
            "    while (k) {",
            "        res *= n; tmp *= k;",
            "        ll d = gcd(res, tmp);",
            "        res /= d; tmp /= d;",
            "        n--; k--;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "nCk (no MOD)"
    },
    "Binomial Coefficients": {
        "prefix": "nCk",
        "body": [
            "ll qexp(ll a, ll b, ll m) {",
            "    ll res = 1;",
            "    while (b) {",
            "        if (b % 2) res = res * a % m;",
            "        a = a * a % m;",
            "        b /= 2;",
            "    }",
            "    return res;",
            "}",
            "",
            "vector<ll> fact, invf;",
            "",
            "void precompute(int n) {",
            "    fact.assign(n + 1, 1); ",
            "    for (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i % MOD;",
            "    invf.assign(n + 1, 1);",
            "    invf[n] = qexp(fact[n], MOD - 2, MOD);",
            "    for (int i = n - 1; i > 0; i--) invf[i] = invf[i + 1] * (i + 1) % MOD;",
            "}",
            "",
            "ll nCk(int n, int k) {",
            "    if (k < 0 || k > n) return 0;",
            "    return fact[n] * invf[k] % MOD * invf[n - k] % MOD;",
            "    // return fact[n] * qexp(fact[k], MOD - 2, MOD) % MOD * qexp(fact[n - k], MOD - 2, MOD) % MOD;",
            "}"
        ],
        "description": "Binomial Coefficients"
    },
    "Matrix": {
        "prefix": "matrix",
        "body": [
            "template <class T> struct matrix {",
            "    vector<vector<T>> m;",
            "    int r, c;",
            "    matrix() : r(), c() {}",
            "    matrix(int r, int c, T x) : r(r), c(c), m(r, vector<T>(c, x)) {}",
            "    matrix(int n) : matrix(n, n, 0) { // identity matrix",
            "        for (int i = 0; i < n; i++) m[i][i] = 1;",
            "    }",
            "    matrix operator+ (matrix<T> b) {",
            "        matrix<T> a = *this;",
            "        assert(a.r == b.r); ",
            "        assert(a.c == b.c);",
            "        matrix<T> o(a.r, a.c, 0);",
            "        for (int i = 0; i < a.r; i++)",
            "            for (int j = 0; j < a.c; j++)",
            "                    o.m[i][j] = a.m[i][j] + b.m[i][j];",
            "        return o;",
            "    }",
            "    matrix operator- (matrix<T> b) {",
            "        matrix<T> a = *this;",
            "        assert(a.r == b.r); ",
            "        assert(a.c == b.c);",
            "        matrix<T> o(a.r, a.c, 0);",
            "        for (int i = 0; i < a.r; i++)",
            "            for (int j = 0; j < a.c; j++)",
            "                    o.m[i][j] = a.m[i][j] - b.m[i][j];",
            "        return o;",
            "    }",
            "    matrix operator* (matrix<T> b) {",
            "        matrix<T> a = *this;",
            "        assert(a.c == b.r);",
            "        matrix<T> o(a.r, b.c, 0);",
            "        for (int i = 0; i < a.r; i++)",
            "            for (int j = 0; j < b.c; j++)",
            "                for (int k = 0; k < a.c; k++)",
            "                    o.m[i][j] = o.m[i][j] + a.m[i][k] * b.m[k][j];",
            "        return o;",
            "    }",
            "    matrix operator^ (ll b) {",
            "        matrix<T> a = *this;",
            "        assert(a.r == a.c);",
            "        matrix<T> o(a.r);",
            "        while (b) {",
            "            if (b % 2) o = o * a;",
            "            a = a * a;",
            "            b /= 2;",
            "        }",
            "        return o;",
            "    }",
            "    void print() {",
            "        for (int i = 0; i < r; i++) {",
            "            for (int j = 0; j < c; j++) cout << m[i][j] << \" \";",
            "            cout << \"\\n\";",
            "        }",
            "    }",
            "};"
        ],
        "description": "Matrix"
    },
    "Quick Exponention": {
        "prefix": "qexp",
        "body": [
            "ll qexp(ll a, ll b, ll m) {",
            "    ll res = 1;",
            "    while (b) {",
            "        if (b % 2) res = res * a % m;",
            "        a = a * a % m;",
            "        b /= 2;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Quick Exponention"
    },
    "Max Flow Algorithm": {
        "prefix": "max_flow",
        "body": [
            "struct max_flow_graph {",
            "    struct edge {",
            "        int u, v, cap, flow;",
            "    };",
            "    int n; ",
            "    vector<edge> el; ",
            "    vector<vector<int>> adj;",
            "    vector<int> dist, par, vis;",
            "    max_flow_graph(int _n) : n(_n), adj(_n) {}",
            "    void add_edge(int u, int v, int w) {",
            "        adj[u].push_back(el.size());",
            "        el.push_back({u, v, w, 0});",
            "        adj[v].push_back(el.size());",
            "        el.push_back({v, u, 0, 0}); ",
            "    }",
            "    int send_one_flow(int s, int e) {",
            "        int nf = INF;",
            "        for (int u = e; u != s; u = el[par[u]].u) {",
            "            nf = min(nf, el[par[u]].cap - el[par[u]].flow);",
            "        }",
            "        for (int u = e; u != s; u = el[par[u]].u) {",
            "            el[par[u]].flow += nf;",
            "            el[par[u]^1].flow -= nf;",
            "        }",
            "        return nf;",
            "    }",
            "    bool bfs(int s, int e) {",
            "        dist.assign(n, INF);",
            "        par.assign(n, 0);",
            "        queue<int> q;",
            "        q.push(s); dist[s] = 0;",
            "        while (q.size()) {",
            "            int u = q.front(); q.pop();",
            "            if (u == e) break;",
            "            for (int idx : adj[u]) {",
            "                if (el[idx].cap > el[idx].flow && dist[el[idx].v] > dist[el[idx].u] + 1) {",
            "                    dist[el[idx].v] = dist[el[idx].u] + 1;",
            "                    par[el[idx].v] = idx;",
            "                    q.push(el[idx].v);",
            "                }",
            "            }",
            "        }",
            "        return dist[e] < INF;",
            "    }",
            "    int dfs(int s, int e, int f = INF) {",
            "        if (s == e || f == 0) return f;",
            "        for (int idx : adj[s]) {",
            "            if (dist[el[idx].v] != dist[s] + 1) continue;",
            "            if (int nf = dfs(el[idx].v, e, min(f, el[idx].cap - el[idx].flow))) {",
            "                el[idx].flow += nf;",
            "                el[idx^1].flow -= nf;",
            "                return nf;",
            "            }",
            "        }",
            "        return 0;",
            "    }",
            "    ll edmonds_karp(int s, int e) {",
            "        ll mf = 0;",
            "        while (bfs(s, e)) mf += send_one_flow(s, e);",
            "        return mf;",
            "    }",
            "    ll dinic(int s, int e) {",
            "        ll mf = 0;",
            "        while (bfs(s, e)) {",
            "            while (int nf = dfs(s, e)) mf += nf;",
            "        }",
            "        return mf;",
            "    }",
            "    void dfs_cut(int u) {",
            "        vis[u] = 1;",
            "        for (int idx : adj[u]) {",
            "            auto [_, v, cap, flow] = el[idx];",
            "            if (vis[v] || flow >= cap) continue;",
            "            dfs_cut(v);",
            "        }",
            "    }",
            "    vector<ar<int,2>> min_cut(int s, int e) {",
            "        ll mf = dinic(s, e);",
            "        vis.assign(n, 0);",
            "        dfs_cut(s);",
            "        vector<ar<int,2>> res;",
            "        for (auto [u, v, cap, flow] : el) {",
            "            if (vis[u] != vis[v] && cap == flow) {",
            "                res.push_back({u, v});",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "Max Flow Algorithm"
    },
    "Basic Sieve": {
        "prefix": "sieve",
        "body": [
            "vector<int> primes, is_prime, spf;",
            "",
            "void sieve(int n) {",
            "    primes.clear();",
            "    is_prime.assign(n + 1, 1);",
            "    spf.assign(n + 1, 0);",
            "    is_prime[0] = is_prime[1] = false;",
            "    for (ll i = 2; i <= n; i++) {",
            "        if (is_prime[i]) {",
            "            primes.push_back(i);",
            "            spf[i] = i;",
            "            for (ll j = i * i; j <= n; j += i) {",
            "                is_prime[j] = false;",
            "                spf[j] = i;",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "Basic Sieve"
    },
    "Linear Sieve": {
        "prefix": "sieve_advanced",
        "body": [
            "vector<int> primes, is_prime, spf, mobius, phi;",
            "",
            "void sieve(int n) {",
            "    primes.clear();",
            "    is_prime.assign(n + 1, 1);",
            "    spf.assign(n + 1, 0);",
            "    mobius.assign(n + 1, 0);",
            "    phi.assign(n + 1, 0);",
            "    is_prime[0] = is_prime[1] = 0;",
            "    mobius[1] = phi[1] = 1;",
            "    for (ll i = 2; i <= n; i++) {",
            "        if (is_prime[i]) {",
            "            primes.push_back(i);",
            "            spf[i] = i;",
            "            mobius[i] = -1;",
            "            phi[i] = i - 1;",
            "        }",
            "        for (auto p : primes) {",
            "            if (i * p > n || p > spf[i]) break;",
            "            is_prime[i * p] = 0;",
            "            spf[i * p] = p;",
            "            mobius[i * p] = (spf[i] == p) ? 0 : -mobius[i];",
            "            phi[i * p] = (spf[i] == p) ? phi[i] * p : phi[i] * phi[p];",
            "        }",
            "    }",
            "}"
        ],
        "description": "Linear Sieve"
    },
    "Modular Arithmetic": {
        "prefix": "mint",
        "body": [
            "template<int _MOD> struct Modular {",
            "    int v; explicit operator int() const { return v; } // explicit -> don't silently convert to int",
            "    Modular() { v = 0; }",
            "    Modular(ll _v) { v = int((-_MOD < _v && _v < _MOD) ? _v : _v % _MOD); if (v < 0) v += _MOD; }",
            "    friend std::ostream& operator<<(std::ostream& out, const Modular& n) { return out << int(n); }",
            "    friend std::istream& operator>>(std::istream& in, Modular& n) { ll v_; in >> v_; n = Modular(v_); return in; }",
            "",
            "    friend bool operator==(const Modular& a, const Modular& b) { return a.v == b.v; }",
            "    friend bool operator!=(const Modular& a, const Modular& b) { return a.v != b.v; }",
            "    friend bool operator<(const Modular& a, const Modular& b) { return a.v < b.v; }",
            "",
            "    Modular& operator+=(const Modular& m) { if ((v += m.v) >= _MOD) v -= _MOD; return *this; }",
            "    Modular& operator-=(const Modular& m) { if ((v -= m.v) < 0) v += _MOD; return *this; }",
            "    Modular& operator*=(const Modular& m) { v = int((ll)v*m.v%_MOD); return *this; }",
            "    Modular& operator/=(const Modular& m) { return (*this) *= inv(m); }",
            "    Modular operator-() const { return Modular(-v); }",
            "    Modular& operator++() { return *this += 1; }",
            "    Modular& operator--() { return *this -= 1; }",
            "    friend Modular pow(Modular a, ll p) {",
            "        Modular ans = 1; assert(p >= 0);",
            "        for (; p; p /= 2, a *= a) if (p&1) ans *= a;",
            "        return ans; ",
            "    }",
            "    friend Modular inv(const Modular& a) { assert(a.v != 0); return pow(a,_MOD-2); }",
            "",
            "    friend Modular operator+(Modular a, const Modular& b) { return a += b; }",
            "    friend Modular operator-(Modular a, const Modular& b) { return a -= b; }",
            "    friend Modular operator*(Modular a, const Modular& b) { return a *= b; }",
            "    friend Modular operator/(Modular a, const Modular& b) { return a /= b; }",
            "    friend Modular operator++(Modular& a, int) { Modular r = a; ++a; return r; }friend Modular operator--(Modular& a, int) { Modular r = a; --a; return r; }",
            "};",
            "",
            "using mint = Modular<MOD>;"
        ],
        "description": "Modular Arithmetic"
    },
    "Floor Sum": {
        "prefix": "floor_sum",
        "body": [
            "// return floor(a * 0 + b) + floor(a * 1 + b) + ... + florr(a * (n - 1) + b) in O(log(n + m + a + b))",
            "ll floor_sum(ll n, ll m, ll a, ll b) {",
            "    ll res = 0;",
            "    if (a >= m) {",
            "        res += (a / m) * (n - 1) * n / 2;",
            "        a %= m;",
            "    }",
            "    if (b >= m) {",
            "        res += (b / m) * n;",
            "        b %= m;",
            "    }",
            "    ll y = (a * n + b) / m, x = y * m - b;",
            "    if (y == 0) return res;",
            "    res += y * (n - (x + a - 1) / a);",
            "    res += floor_sum(y, a, m, (a - x % a) % a);",
            "    return res;",
            "}"
        ],
        "description": "Floor Sum"
    },
    "Li-Chao Segment Tree": {
        "prefix": "lichaotree",
        "body": [
            "struct lichaotree{",
            "    struct tdata {",
            "        ll m, c; // y = m * x + c",
            "        tdata() {}",
            "        tdata(ll m, ll c): m(m), c(c) {}",
            "        ll operator()(ll x) {return m * x + c;}",
            "    };",
            "    int ln(int node) {return 2 * node;}",
            "    int rn(int node) {return 2 * node + 1;}",
            "    int n; vector<tdata> st;",
            "    lichaotree(int _n): n(_n), st(4 * _n, {INF, INF}) {}",
            "    void update(int node, int start, int end, tdata y) {",
            "        int mid = (start + end) / 2;",
            "        bool b1 = y(start) < st[node](start);",
            "        bool b2 = y(mid) < st[node](mid);",
            "        if (b2) swap(st[node], y);",
            "        if (start + 1 == end) return;",
            "        if (b1 != b2) update(ln(node), start, mid, y);",
            "        else update(rn(node), mid, end, y);",
            "    }",
            "    ll query(int node, int start, int end, int x) {",
            "        if (start + 1 == end) return st[node](x);",
            "        int mid = (start + end) / 2;",
            "        if (x < mid) return min(st[node](x), query(ln(node), start, mid, x));",
            "        return min(st[node](x), query(rn(node), mid, end, x));",
            "    }",
            "    void update(tdata y) {update(1, 0, n, y);}",
            "    ll query(int x) {return query(1, 0, n, x);}",
            "};"
        ],
        "description": "Li-Chao Segment Tree"
    },
    "Li-Chao Dynamic Segment Tree": {
        "prefix": "lichaotree_dynamic",
        "body": [
            "struct lichaotree {",
            "    struct line {",
            "        ll m, c;",
            "        line(ll m, ll c): m(m), c(c) {}",
            "        ll operator()(ll x) {return m * x + c;}",
            "    };",
            "    struct tdata {",
            "        line seg;",
            "        tdata *ln = NULL, *rn = NULL;",
            "        tdata(line seg): seg(seg) {}",
            "    };",
            "    int n; tdata *st;",
            "    lichaotree(int _n): n(_n) {st = new tdata({INF, INF});}",
            "    void update(tdata *node, int start, int end, line y) {",
            "        int mid = (start + end) / 2;",
            "        bool b1 = y(start) < node->seg(start);",
            "        bool b2 = y(mid) < node->seg(mid);",
            "        if (b2) swap(node->seg, y);",
            "        if (start + 1 == end) return;",
            "        if (b1 != b2) {",
            "            if (node->ln) update(node->ln, start, mid, y);",
            "            else node->ln = new tdata(y);",
            "        }",
            "        else {",
            "            if (node->rn) update(node->rn, mid, end, y);",
            "            else node->rn = new tdata(y);",
            "        }",
            "    }",
            "    ll query(tdata *node, ll start, ll end, ll x) {",
            "        if (start + 1 == end) return node->seg(x);",
            "        ll mid = (start + end) / 2;",
            "        if (x < mid && node->ln) return min(node->seg(x), query(node->ln, start, mid, x));",
            "        else if (node->rn) return min(node->seg(x), query(node->rn, mid, end, x));",
            "        return node->seg(x);",
            "    }",
            "    void update(line y) {update(st, 0, n, y);}",
            "    ll query(int x) {return query(st, 0, n, x);}",
            "}; "
        ],
        "description": "Li-Chao Dynamic Segment Tree"
    },
    "Convex Hull Trick": {
        "prefix": "cht",
        "body": [
            "struct convexhull {",
            "    struct line {",
            "        ll m, c; ",
            "        line(ll m, ll c): m(m), c(c) {}",
            "        ll operator()(ll x) {return m * x + c;}",
            "    };",
            "    deque<line> dq;",
            "    bool check(line p1, line p2, line p3) { // p1.m > p2.m > p3.m",
            "        return (p1.m - p2.m) * (p2.c - p3.c) >= (p2.m - p3.m) * (p1.c - p2.c);",
            "    }",
            "    void add(line y) { // decreasing slope",
            "        while (dq.size() >= 2 && check(dq[dq.size() - 2], dq[dq.size() - 1], y)) dq.pop_back();",
            "        dq.push_back(y);",
            "    }",
            "    ll query(ll x) { // min query, increasing x",
            "        while (dq.size() >= 2 && dq[0](x) >= dq[1](x)) dq.pop_front();",
            "        return dq[0](x);",
            "    }",
            "    ll query(ll x) { // min query, any x",
            "        int lo = -1, hi = dq.size() - 1;",
            "        while (lo + 1 < hi) {",
            "            int mid = (lo + hi) / 2;",
            "            if (dq[mid](x) >= dq[mid + 1](x)) lo = mid;",
            "            else hi = mid;",
            "        }",
            "        return dq[hi](x);",
            "    }",
            "};"
        ],
        "description": "Convex Hull Trick"
    },
    "Convex Hull Trick (fully dynamic variant)": {
        "prefix": "cht_dynamic",
        "body": [
            "struct Line {",
            "    mutable ll m, b, p;",
            "    bool operator<(const Line& o) const { return m < o.m; }",
            "    bool operator<(ll x) const { return p < x; }",
            "};",
            "",
            "struct LineContainer : multiset<Line, less<>> {",
            "    // (for doubles, use inf = 1/.0, div(a,b) = a/b)",
            "    const ll inf = LLONG_MAX;",
            "    ll div(ll a, ll b) { // floored division",
            "        return a / b - ((a ^ b) < 0 && a % b); }",
            "    bool isect(iterator x, iterator y) {",
            "        if (y == end()) { x->p = inf; return false; }",
            "        if (x->m == y->m) x->p = x->b > y->b ? inf : -inf;",
            "        else x->p = div(y->b - x->b, x->m - y->m);",
            "        return x->p >= y->p;",
            "    }",
            "    void add(ll m, ll b) {",
            "        auto z = insert({m, b, 0}), y = z++, x = y;",
            "        while (isect(y, z)) z = erase(z);",
            "        if (x != begin() && isect(--x, y)) isect(x, y = erase(y));",
            "        while ((y = x) != begin() && (--x)->p >= y->p)",
            "        isect(x, erase(y));",
            "    }",
            "    ll query(ll x) {",
            "        assert(!empty());",
            "        auto l = *lower_bound(x);",
            "        return l.m * x + l.b;",
            "    }",
            "} cht;"
        ],
        "description": "Convex Hull Trick (fully dynamic variant)"
    },
    "Median Heap": {
        "prefix": "median_heap",
        "body": [
            "multiset<int> lo, hi;",
            "",
            "void add(int x) {",
            "    int m = *lo.rbegin(); // current median",
            "    if (x > m) {",
            "        hi.insert(x);",
            "        if (hi.size() > k / 2) {",
            "            lo.insert(*hi.begin());",
            "            hi.erase(hi.begin());",
            "        }",
            "    } else {",
            "        lo.insert(x);",
            "        if (lo.size() > (k + 1) / 2) {",
            "            hi.insert(*lo.rbegin());",
            "            lo.erase(prev(lo.end()));",
            "        }",
            "    }",
            "}",
            "",
            "void remove(int x) {",
            "    if (hi.count(x)) hi.erase(hi.find(x));",
            "    else lo.erase(lo.find(x));",
            "    if (lo.empty()) {",
            "        lo.insert(*hi.begin());",
            "        hi.erase(hi.begin());",
            "    }",
            "}"
        ],
        "description": "Median Heap"
    },
    "Z Algorithm": {
        "prefix": "z_algo",
        "body": [
            "// f[i] = length of the longest common prefix between s and the substring s[i...n-1]",
            "vector<int> z_func(string s) {",
            "    int n = s.size();",
            "    vector<int> f(n); // f[0] = 0 by default",
            "    for (int i = 1, l = 0, r = 0; i < n; i++) {",
            "        if (i <= r) f[i] = min(r - i + 1, f[i - l]);",
            "        while (i + f[i] < n && s[f[i]] == s[i + f[i]]) f[i]++;",
            "        if (i + f[i] - 1 > r) l = i, r = i + f[i] - 1;",
            "    }",
            "    return f;",
            "}",
            "",
            "int cnt_occ(string s, string t) {",
            "    string ts = t + \"#\" + s;",
            "    int n = t.size(), nm = ts.size();",
            "    auto f = z_func(ts);",
            "    int res = 0;",
            "    for (int i = n + 1; i < nm; i++) res += (f[i] == n);",
            "    return res;",
            "}"
        ],
        "description": "Z Algorithm"
    },
    "KnuthMorrisPratt (prefix function)": {
        "prefix": "kmp",
        "body": [
            "// f[i] = length of the longest proper prefix of the substring s[0...i] which is also a suffix of this substring",
            "vector<int> prefix_func(string s) {",
            "    int n = s.size();",
            "    vector<int> f(n); // f[0] = 0 by default",
            "    for (int i = 1; i < n; i++) {",
            "        int j = f[i - 1];",
            "        while (j && s[i] != s[j]) j = f[j - 1];",
            "        f[i] = j + (s[i] == s[j]);",
            "    }",
            "    return f;",
            "}",
            "",
            "int cnt_occ(string s, string t) {",
            "    string ts = t + \"#\" + s;",
            "    int n = t.size(), nm = ts.size();",
            "    auto f = prefix_func(ts);",
            "    int res = 0;",
            "    for (int i = n + 1; i < nm; i++) res += (f[i] == n);",
            "    return res;",
            "}"
        ],
        "description": "KnuthMorrisPratt (prefix function)"
    },
    "Suffix Array": {
        "prefix": "suffix_array",
        "body": [
            "struct suffix_array {",
            "    const int MAX_C = 256;",
            "    int n; string s;",
            "    vector<int> pos, rnk, lcp;",
            "    suffix_array(string s) : n(s.size()), s(s) {}",
            "    void build_sa() { ",
            "        pos.assign(n, 0); rnk.assign(n, 0);",
            "        vector<int> cnt(MAX_C);",
            "        for (int i = 0; i < n; i++) cnt[s[i]]++;",
            "        for (int i = 1; i < MAX_C; i++) cnt[i] += cnt[i - 1];",
            "        for (int i = n - 1; i >= 0; i--) pos[--cnt[s[i]]] = i;",
            "        for (int i = 1; i < n; i++) rnk[pos[i]] = rnk[pos[i - 1]] + (s[pos[i]] != s[pos[i - 1]]);",
            "        for (int k = 0; (1 << k) < n; k++) {",
            "            vector<int> npos(n), nrnk(n), ncnt(n);",
            "            for (int i = 0; i < n; i++) pos[i] = (pos[i] - (1 << k) + n) % n;",
            "            for (int i = 0; i < n; i++) ncnt[rnk[i]]++;",
            "            for (int i = 1; i < n; i++) ncnt[i] += ncnt[i - 1];",
            "            for (int i = n - 1; i >= 0; i--) npos[--ncnt[rnk[pos[i]]]] = pos[i];",
            "            for (int i = 1; i < n; i++) {",
            "                ar<int,2> cur = {rnk[npos[i]], rnk[(npos[i] + (1 << k)) % n]};",
            "                ar<int,2> pre = {rnk[npos[i - 1]], rnk[(npos[i - 1] + (1 << k)) % n]};",
            "                nrnk[npos[i]] = nrnk[npos[i - 1]] + (cur != pre);",
            "            }",
            "            swap(pos, npos), swap(rnk, nrnk);",
            "        }",
            "    }",
            "    void build_lcp() { // lcp[i] = LCP(pos[i], pos[i - 1])",
            "        lcp.assign(n, 0);",
            "        for (int i = 0, k = 0; i < n - 1; i++, k = max(k - 1, 0)) {",
            "            // pos[rnk[i]] == i",
            "            int j = pos[rnk[i] - 1];",
            "            while (s[i + k] == s[j + k]) k++;",
            "            lcp[rnk[i]] = k;",
            "        }",
            "    }",
            "};"
        ],
        "description": "Suffix Array"
    },
    "String Hashing": {
        "prefix": "hash",
        "body": [
            "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
            "ll rand(ll l, ll r) {return uniform_int_distribution(l, r)(rng);}",
            "const int BASE = rand(300, 1e9);",
            "const int NUM_MOD = 4;",
            "const ll MODS[] = {(int)1e9 + 2277, (int)1e9 + 5277, (int)1e9 + 8277, (int)1e9 + 9277};",
            "struct Hash {",
            "    vector<ll> H[NUM_MOD], P[NUM_MOD];",
            "    Hash(string s) {",
            "        for (int i = 0; i < NUM_MOD; i++) {",
            "            P[i].push_back(1);",
            "            H[i].push_back(0);",
            "        }",
            "        for (char c : s) {",
            "            for (int i = 0; i < NUM_MOD; i++) {",
            "                P[i].push_back(P[i].back() * BASE % MODS[i]);",
            "                H[i].push_back((H[i].back() * BASE + c) % MODS[i]);",
            "            }",
            "        }",
            "    } ",
            "    ar<ll,NUM_MOD> operator()(int l, int r) {",
            "        ar<ll,NUM_MOD> res;",
            "        for (int i = 0; i < NUM_MOD; i++) {",
            "            res[i] = (H[i][r + 1] - H[i][l] * P[i][r + 1 - l]) % MODS[i];",
            "            if (res[i] < 0) res[i] += MODS[i];",
            "        }",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "String Hashing"
    },
    "Lowest Common Ancestor": {
        "prefix": "lca",
        "body": [
            "const int MAX_L = 20;",
            "",
            "int n, q, par[MAX_N][MAX_L], dep[MAX_N];",
            "vector<int> adj[MAX_N];",
            " ",
            "void dfs(int u, int p = 0) {",
            "    par[u][0] = p;",
            "    for (int i = 1; i < MAX_L; i++) ",
            "        par[u][i] = par[par[u][i - 1]][i - 1];",
            "    for (int v : adj[u]) {",
            "        if (v == p) continue;",
            "        dep[v] = dep[u] + 1;",
            "        dfs(v, u);",
            "    }",
            "}",
            " ",
            "int ancestor(int u, int k) {",
            "    for (int i = 0; i < MAX_L; i++) ",
            "        if (k & (1 << i)) ",
            "            u = par[u][i];",
            "    return u;",
            "}",
            " ",
            "int lca(int u, int v) {",
            "    if (dep[u] < dep[v]) swap(u, v);",
            "    u = ancestor(u, dep[u] - dep[v]);",
            "    if (u == v) return u;",
            "    for (int i = MAX_L - 1; i >= 0; i--)",
            "        if (par[u][i] != par[v][i])",
            "            u = par[u][i], v = par[v][i];",
            "    return par[u][0];",
            "}"
        ],
        "description": "Lowest Common Ancestor"
    },
    "Dijkstra": {
        "prefix": "dijk",
        "body": [
            "int n, m;",
            "vector<ar<int,2>> adj[MAX_N];",
            "vector<ll> dist;",
            "",
            "void dijk(int s) {",
            "    dist.assign(n + 1, INF);",
            "    priority_queue<ar<ll,2>, vector<ar<ll,2>>, greater<ar<ll,2>>> pq;",
            "    dist[s] = 0; pq.push({0, s});",
            "    while (pq.size()) {",
            "        auto [d, u] = pq.top(); pq.pop();",
            "        if (d > dist[u]) continue;",
            "        for (auto [v, w] : adj[u]) {",
            "            if (dist[v] > dist[u] + w) {",
            "                dist[v] = dist[u] + w;",
            "                pq.push({dist[v], v});",
            "            }",
            "        }",
            "    } ",
            "}"
        ],
        "description": "Dijkstra"
    },
    "Dijkstra (Dense graph)": {
        "prefix": "dijk_dense",
        "body": [
            "int n, m;",
            "vector<ar<int,2>> adj[MAX_N];",
            "vector<ll> dist;",
            "",
            "void dijk(int s) {",
            "    dist.assign(n + 1, INF);",
            "    vector<bool> vis(n + 1);",
            "    dist[s] = 0; ",
            "    for (int i = 0; i < n; i++) {",
            "        int u = -1;",
            "        for (int x = 0; x <= n; x++) {",
            "            if (vis[x]) continue;",
            "            if (u == -1 || dist[u] > dist[x]) u = x;",
            "        }",
            "        if (dist[u] == INF) break;",
            "        vis[u] = true;",
            "        for (auto [v, w] : adj[u]) {",
            "            if (dist[v] > dist[u] + w) {",
            "                dist[v] = dist[u] + w;",
            "            }",
            "        }",
            "    }   ",
            "}"
        ],
        "description": "Dijkstra (Dense graph)"
    },
    "Mo's Algorithm": {
        "prefix": "mo",
        "body": [
            "const int SQRT = sqrt(MAX_N);",
            "",
            "struct query {",
            "    int l, r, id;",
            "    const bool operator< (const query& other) const {",
            "        if (l / SQRT == other.l / SQRT) {",
            "            return ((l / SQRT) % 2) ? r > other.r : r < other.r;",
            "        } else {",
            "            return l < other.l;",
            "        }",
            "    }",
            "};",
            "",
            "int n, q, arr[MAX_N], ans[MAX_N], cnt[MAX_N], cur;",
            "vector<query> qs;",
            "",
            "void add(int idx) {",
            "    if (cnt[arr[idx]] == 0) cur++;",
            "    cnt[arr[idx]]++;",
            "}",
            " ",
            "void subtract(int idx) {",
            "    if (cnt[arr[idx]] == 1) cur--;",
            "    cnt[arr[idx]]--;",
            "}",
            "",
            "void compress() {",
            "    map<int,int> mp;",
            "    for (int i = 1; i <= n; i++) mp[arr[i]] = i;",
            "    for (int i = 1; i <= n; i++) arr[i] = mp[arr[i]];",
            "}",
            "",
            "void mo_algo() {",
            "    sort(qs.begin(), qs.end());",
            "    int curL = 0, curR = 0;",
            "    add(0);",
            "    for (auto [l, r, id] : qs) {",
            "        while (curL < l) subtract(curL++);",
            "        while (curL > l) add(--curL);",
            "        while (curR < r) add(++curR);",
            "        while (curR > r) subtract(curR--);",
            "        ans[id] = cur;",
            "    }",
            "}"
        ],
        "description": "Mo's Algorithm"
    },
    "Treap": {
        "prefix": "treap",
        "body": [
            "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
            "struct tdata {",
            "    int val, pri, sz;",
            "    tdata *ln = NULL, *rn = NULL;",
            "    tdata(int val): val(val), pri(rng()), sz(1), ln(), rn() {} ",
            "};",
            "int sz(tdata *node) {return node ? node->sz : 0;}",
            "void push_down(tdata *node) {",
            "    if (!node) return;",
            "}",
            "void pull_up(tdata *node) {",
            "    if (!node) return;",
            "    push_down(node->ln); push_down(node->rn);",
            "    node->sz = sz(node->ln) + sz(node->rn) + 1;",
            "}",
            "void heapify(tdata *node) {",
            "    if (!node) return;",
            "    auto mx = node;",
            "    if (node->ln && node->ln->pri > node->pri) mx = node;",
            "    if (node->rn && node->rn->pri > node->pri) mx = node;",
            "    if (node != mx) {",
            "        swap(node->pri, mx->pri);",
            "        heapify(mx);",
            "    }",
            "}",
            "tdata* build(vector<int> &arr, int start, int end) {",
            "    if (start > end) return NULL;",
            "    int mid = (start + end) / 2;",
            "    auto node = new tdata(arr[mid]);",
            "    node->ln = build(arr, start, mid - 1);",
            "    node->rn = build(arr, mid + 1, end);",
            "    heapify(node); pull_up(node);",
            "    return node;",
            "}",
            "void split(tdata *node, tdata *&ln, tdata *&rn, int k) { // k nodes to ln",
            "    push_down(node);",
            "    if (!node) {",
            "        ln = rn = NULL;",
            "        return;",
            "    }",
            "    if (sz(node->ln) >= k) split(node->ln, ln, node->ln, k), rn = node;",
            "    else split(node->rn, node->rn, rn, k - sz(node->ln) - 1), ln = node;",
            "    pull_up(node);",
            "}",
            "void merge(tdata *&node, tdata *ln, tdata *rn) {",
            "    push_down(ln); push_down(rn);",
            "    if (!ln || !rn) {",
            "        node = ln ? ln : rn;",
            "        return;",
            "    }",
            "    if (ln->pri > rn->pri) merge(ln->rn, ln->rn, rn), node = ln;",
            "    else merge(rn->ln, ln, rn->ln), node = rn;",
            "    pull_up(node);",
            "}",
            "void print(tdata *node) {",
            "    if (!node) return;",
            "    print(node->ln);",
            "    cout << node->val << \" \";",
            "    print(node->rn);",
            "}"
        ],
        "description": "Treap"
    },
    "Heavy-Light Decomposition": {
        "prefix": "hld",
        "body": [
            "template<bool VALS_IN_EDGE> struct HLD { ",
            "    int n, timer;",
            "    vector<vector<int>> adj;",
            "    vector<int> par, tin, tout, head, dep, sz;",
            "    HLD(int _n) : n(_n), adj(_n), par(_n), tin(_n), tout(_n), head(_n), dep(_n), sz(_n) {}",
            "    void add_edge(int u, int v) {",
            "        adj[u].push_back(v);",
            "        adj[v].push_back(u);",
            "    }",
            "    void dfs_sz(int u) {",
            "        sz[u] = 1;",
            "        for (int &v : adj[u]) {",
            "            adj[v].erase(find(adj[v].begin(), adj[v].end(), u)); // remove parent",
            "            par[v] = u; dep[v] = dep[u] + 1;",
            "            dfs_sz(v);",
            "            sz[u] += sz[v];",
            "            if (sz[v] > sz[adj[u][0]]) swap(v, adj[u][0]); // store the heavy node at the beginning",
            "        }",
            "    }",
            "    void dfs_hld(int u) {",
            "        tin[u] = timer++;",
            "        for (int v : adj[u]) {",
            "            head[v] = (v == adj[u][0] ? head[u] : v);",
            "            dfs_hld(v);",
            "        }",
            "    }",
            "    void init(int s = 0) {",
            "        par[s] = dep[s] = timer = 0; head[s] = s; ",
            "        dfs_sz(s); dfs_hld(s);",
            "    }",
            "    int lca(int u, int v) {",
            "        while (head[u] != head[v]) {",
            "            if (dep[head[u]] > dep[head[v]]) swap(u, v);",
            "            v = par[head[v]];",
            "        }",
            "        return dep[u] < dep[v] ? u : v;",
            "    }",
            "    segtree st{n};",
            "    template<class OP> void process_path(int u, int v, OP op) {",
            "        while (head[u] != head[v]) {",
            "            if (dep[head[u]] < dep[head[v]]) swap(u, v);",
            "            op(tin[head[u]], tin[u]);",
            "            u = par[head[u]];",
            "        }",
            "        if (dep[u] > dep[v]) swap(u, v);",
            "        op(tin[u] + VALS_IN_EDGE, tin[v]);",
            "    }",
            "    void update_path(int u, int v, int val) {",
            "        st.update(tin[u], val);",
            "        // process_path(u, v, [this, &val](int l, int r) { st.update(l, r, val); });",
            "    }",
            "    int query_path(int u, int v) {",
            "        int res = 0;",
            "        process_path(u, v, [this, &res](int l, int r) { res = max(res, st.query(l, r).mx); });",
            "        return res;",
            "    }",
            "    // void update_subtree(int u, int val) { st.update(tin[u] + VALS_IN_EDGE, tin[u] + sz[u] - 1, val); }",
            "    // int query_subtree(int u) { return st.query(tin[u] + VALS_IN_EDGE, tin[u] + sz[u] - 1).mx; }",
            "};"
        ],
        "description": "Heavy-Light Decomposition"
    },
    "Kosaraju's Algorithm": {
        "prefix": "scc",
        "body": [
            "int n, m, scc, vis[MAX_N], head[MAX_N];",
            "vector<int> adj[MAX_N], adj_T[MAX_N], comp[MAX_N], topo;",
            " ",
            "void dfs1(int u) {",
            "    vis[u] = true;",
            "    for (int v : adj[u]) {",
            "        if (vis[v]) continue;",
            "        dfs1(v);",
            "    }",
            "    topo.push_back(u);",
            "}",
            " ",
            "void dfs2(int u) {",
            "    vis[u] = true;",
            "    comp[scc].push_back(u);",
            "    head[u] = scc;",
            "    for (int v : adj_T[u]) {",
            "        if (vis[v]) continue;",
            "        dfs2(v);",
            "    }",
            "}",
            "",
            "void kosaraju() {",
            "    for (int i = 1; i <= n; i++) {",
            "        if (vis[i]) continue;",
            "        dfs1(i);",
            "    }",
            "    memset(vis, 0, sizeof vis);",
            "    reverse(topo.begin(), topo.end());",
            "    for (int i : topo) {",
            "        if (vis[i]) continue;",
            "        dfs2(i);",
            "        scc++;",
            "    }",
            "}"
        ],
        "description": "Kosaraju's Algorithm"
    },
    "Centroid Decomposition": {
        "prefix": "centroid",
        "body": [
            "struct Centroid {",
            "    int n;",
            "    vector<vector<int>> adj;",
            "    vector<int> par, vis, sz;",
            "    Centroid(int _n) : n(_n), adj(_n), par(_n), vis(_n), sz(_n) {}",
            "    void add_edge(int u, int v) {",
            "        adj[u].push_back(v);",
            "        adj[v].push_back(u);",
            "    }",
            "    int dfs_sz(int u, int p = 0) {",
            "        sz[u] = 1;",
            "        for (int v : adj[u]) {",
            "            if (v == p || vis[v]) continue;",
            "            sz[u] += dfs_sz(v, u);",
            "        }",
            "        return sz[u];",
            "    }",
            "    int dfs_centroid(int u, int p = 0) {",
            "        for (int v : adj[u]) {",
            "            if (v == p || vis[v]) continue;",
            "            if (sz[v] > n / 2) return dfs_centroid(v, u);",
            "        }",
            "        return u;",
            "    }",
            "    void init(int s = 0, int p = 0) {",
            "        n = dfs_sz(s);",
            "        int u = dfs_centroid(s, p);",
            "        vis[u] = 1; par[u] = p; ",
            "        for (int v : adj[u]) {",
            "            if (vis[v]) continue;",
            "            init(v, u);",
            "        }",
            "    }",
            "};"
        ],
        "description": "Centroid Decomposition"
    },
    "Linear Diophantine Equation": {
        "prefix": "lde",
        "body": [
            "ll gcd(ll a, ll b, ll &x, ll &y) {",
            "    if (b == 0) {x = 1, y = 0; return a;}",
            "    ll x1, y1, d = gcd(b, a % b, x1, y1);",
            "    x = y1;",
            "    y = x1 - y1 * (a / b);",
            "    return d;",
            "}",
            "",
            "// solve ax + by = c",
            "bool lde(ll a, ll b, ll c, ll &x, ll &y) {",
            "    ll d = gcd(abs(a), abs(b), x, y);",
            "    if (c % d) return false; ",
            "    x *= c / d; ",
            "    y *= c / d;",
            "    if (a < 0) x = -x;",
            "    if (b < 0) y = -y;",
            "    return true;",
            "}",
            "",
            "void shift(ll a, ll b, ll &x, ll &y, ll cnt) {",
            "    x += cnt * b;",
            "    y -= cnt * a;",
            "}"
        ],
        "description": "Linear Diophantine Equation"
    },
    "Linear Congruence Equation": {
        "prefix": "lce",
        "body": [
            "ll gcd(ll a, ll b, ll &x, ll &y) {",
            "    if (b == 0) {x = 1, y = 0; return a;}",
            "    ll x1, y1, d = gcd(b, a % b, x1, y1);",
            "    x = y1;",
            "    y = x1 - y1 * (a / b);",
            "    return d;",
            "}",
            "",
            "ll inv_mod(ll a, ll m) {",
            "    ll x, y;",
            "    gcd(a, m, x, y);",
            "    return (m + x % m) % m;",
            "}",
            "",
            "// solve ax === b (mod m)",
            "ll lce(ll a, ll b, ll m) {",
            "    ll d = gcd(a, m);",
            "    if (d != 1) {",
            "        if (b % d) return -1;",
            "        a /= d; b /= d; m /= d;",
            "    }",
            "    return b * inv_mod(a, m) % m;",
            "}"
        ],
        "description": "Linear Congruence Equation"
    },
    "Compress coordinates": {
        "prefix": "compress",
        "body": [
            "vector<int> b = a;",
            "sort(b.begin(), b.end());",
            "b.resize(unique(b.begin(), b.end()) - b.begin());",
            "for (int i = 0; i < n; i++) a[i] = lower_bound(b.begin(), b.end(), a[i]) - b.begin();"
        ],
        "description": "Compress coordinates"
    },
    "DFS": {
        "prefix": "dfs",
        "body": [
            "int n;",
            "vector<int> adj[MAX_N];",
            "",
            "void dfs(int u, int p = 0) {",
            "    for (int v : adj[u]) {",
            "        if (v == p) continue;",
            "        dfs(v, u);",
            "    }",
            "}",
            "",
            "void solve() {",
            "    cin >> n;",
            "    for (int i = 0; i < n - 1; i++) {",
            "        int u, v; cin >> u >> v;",
            "        adj[u].push_back(v);",
            "        adj[v].push_back(u);",
            "    }",
            "}"
        ],
        "description": "DFS"
    },
    "Sack (DSU on tree)": {
        "prefix": "sack",
        "body": [
            "int n, sz[MAX_N];",
            "vector<int> adj[MAX_N], vec[MAX_N];",
            "",
            "void dfs_sz(int u, int p = 0) {",
            "    sz[u] = 1;",
            "    for (int v : adj[u]) {",
            "        if (v == p) continue;",
            "        dfs_sz(v, u);",
            "        sz[u] += sz[v];",
            "    }",
            "}",
            "",
            "void update(int u, int x) {",
            "    // DO SOMETHING at node u",
            "",
            "}",
            "",
            "void dfs(int u, int p = 0, bool keep = 0) {",
            "    ar<int,2> hv = {-1, -1};",
            "    for (int v : adj[u]) {",
            "        if (v == p) continue;",
            "        hv = max(hv, {sz[v], v});",
            "    }",
            "    for (int v : adj[u]) {",
            "        if (v == p || v == hv[1]) continue;",
            "        dfs(v, u, 0);",
            "    }",
            "    if (hv[1] != -1) {",
            "        dfs(hv[1], u, 1);",
            "        swap(vec[u], vec[hv[1]]);",
            "    }",
            "    vec[u].push_back(u);",
            "    update(u, 1);",
            "    for (int v : adj[u]) {",
            "        if (v == p || v == hv[1]) continue;",
            "        for (int x : vec[v]) {",
            "            update(x, 1);",
            "            vec[u].push_back(x);",
            "        }",
            "    }",
            "    // ANS for all queries at node u",
            "    ",
            "    //",
            "    if (!keep) {",
            "        for (int v : vec[u]) {",
            "            update(v, -1);",
            "        }",
            "    }",
            "}"
        ],
        "description": "Sack (DSU on tree)"
    },
    "Euler Circuit Undirected (Hierholzers Algorithm)": {
        "prefix": "euler",
        "body": [
            "int n, m;",
            "set<int> adj[MAX_N];",
            "",
            "// print the euler circuit in an undirected graph",
            "void euler() { ",
            "    for (int i = 1; i <= n; i++) {",
            "        if (adj[i].size() % 2) {",
            "            cout << \"IMPOSSIBLE\\n\";",
            "            return;",
            "        }",
            "    }",
            "    vector<int> res;",
            "    stack<int> st; st.push(1);",
            "    while (st.size()) {",
            "        int u = st.top();",
            "        if (adj[u].empty()) {",
            "            res.push_back(u);",
            "            st.pop();",
            "        } else {",
            "            int v = *adj[u].begin();",
            "            adj[u].erase(v);",
            "            adj[v].erase(u);",
            "            st.push(v);",
            "        }",
            "    }",
            "    if ((int) res.size() != m + 1) {",
            "        cout << \"IMPOSSIBLE\\n\";",
            "        return;",
            "    }",
            "    for (int u : res) cout << u << \" \";",
            "    cout << \"\\n\";",
            "}",
            "",
            "void solve() {",
            "    cin >> n >> m;",
            "    for (int i = 0; i < m; i++) {",
            "        int u, v; cin >> u >> v;",
            "        adj[u].insert(v);",
            "        adj[v].insert(u);",
            "    }",
            "    euler();",
            "}"
        ],
        "description": "Euler Circuit Undirected (Hierholzers Algorithm)"
    },
    "Euler Path Directed (Hierholzers Algorithm)": {
        "prefix": "euler",
        "body": [
            "int n, m, in_deg[MAX_N], out_deg[MAX_N];",
            "vector<int> adj[MAX_N];",
            "",
            "// print the euler path (from 1 to n) in a directed graph",
            "void euler() { ",
            "    if (out_deg[1] != in_deg[1] + 1 || in_deg[n] != out_deg[n] + 1) {",
            "        cout << \"IMPOSSIBLE\\n\";",
            "        return;",
            "    }",
            "    for (int i = 2; i < n; i++) {",
            "        if (in_deg[i] != out_deg[i]) {",
            "            cout << \"IMPOSSIBLE\\n\";",
            "            return;",
            "        }",
            "    }",
            "    vector<int> res;",
            "    stack<int> st; st.push(1);",
            "    while (st.size()) {",
            "        int u = st.top();",
            "        if (adj[u].empty()) {",
            "            res.push_back(u);",
            "            st.pop();",
            "        } else {",
            "            int v = adj[u].back(); adj[u].pop_back();",
            "            st.push(v);",
            "        }",
            "    }",
            "    if ((int) res.size() != m + 1) {",
            "        cout << \"IMPOSSIBLE\\n\";",
            "        return;",
            "    }",
            "    reverse(res.begin(), res.end());",
            "    for (int u : res) cout << u << \" \";",
            "    cout << \"\\n\";",
            "}",
            "",
            "void solve() {",
            "    cin >> n >> m;",
            "    for (int i = 0; i < m; i++) {",
            "        int u, v; cin >> u >> v;",
            "        adj[u].push_back(v);",
            "        out_deg[u]++; in_deg[v]++;",
            "    }",
            "    euler();",
            "}"
        ],
        "description": "Euler Path Directed (Hierholzers Algorithm)"
    },
    "Geometry (kactl library)": {
        "prefix": "point",
        "body": [
            "template <class T> int sgn(T x) { return (x > 0) - (x < 0); }",
            "template <class T> struct Point {",
            "    T x, y;",
            "    Point() : x(0), y(0) {}",
            "    Point(const T& x, const T& y) : x(x), y(y) {}",
            "",
            "    friend std::ostream& operator<<(std::ostream& out, const Point& p) { return out << \"(\" << p.x << \",\" << p.y << \")\"; }",
            "    friend std::istream& operator>>(std::istream& in, Point& p) { return in >> p.x >> p.y; }",
            "",
            "    friend bool operator==(const Point& a, const Point& b) { return tie(a.x, a.y) == tie(b.x, b.y); }",
            "    friend bool operator!=(const Point& a, const Point& b) { return tie(a.x, a.y) != tie(b.x, b.y); }",
            "    friend bool operator<(const Point& a, const Point& b) { return tie(a.x, a.y) < tie(b.x, b.y); }",
            "",
            "    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }",
            "    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }",
            "    Point operator*(const T& d) const { return Point(x * d, y * d); }",
            "    Point operator/(const T& d) const { return Point(x / d, y / d); }",
            "",
            "    T dot(const Point& p) const { return x * p.x + y * p.y; }",
            "    T cross(const Point& p) const { return x * p.y - y  *p.x; }",
            "    T cross(const Point& a, const Point& b) const { return (a - *this).cross(b - *this); }",
            "    T dist2() const { return x * x + y * y; }",
            "    double dist() const { return sqrt((double)dist2()); }",
            "    double angle() const { return atan2(y, x); } // [-pi, pi] to x-axis",
            "",
            "    Point unit() const { return *this / dist(); } // unit vector",
            "    Point perp() const { return P(-y, x); } // rotates +90 degrees",
            "    Point normal() const { return perp().unit(); }",
            "    Point rotate(const double& a) const { return P(x*cos(a) - y*sin(a), x*sin(a) + y*cos(a)); } // ccw around (0,0)",
            "};",
            "",
            "using pt = Point<ll>;"
        ],
        "description": "Geometry (kactl library)"
    },
    "Unordered Hash": {
        "prefix": "unordered_hash",
        "body": [
            "struct custom_hash {",
            "    static uint64_t splitmix64(uint64_t x) {",
            "        x += 0x9e3779b97f4a7c15;",
            "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
            "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
            "        return x ^ (x >> 31);",
            "    }",
            "    size_t operator()(uint64_t x) const {",
            "        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
            "        return splitmix64(x + FIXED_RANDOM);",
            "        // return splitmix64(x.first + FIXED_RANDOM)^(splitmix64(x.second + FIXED_RANDOM) >> 1);",
            "    }",
            "};"
        ],
        "description": "Unordered Hash"
    }
}